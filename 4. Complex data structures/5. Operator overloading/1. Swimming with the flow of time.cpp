//Плыть по течению времени
//Помните структуру my_time из позапрошлого урока? Она вернулась, и теперь мы хотим ее отсортировать. Сортировку мы написали за вас, так что теперь вам необходимо только реализовать аналогичную структуру, но добавив к ней оператор < - при его использовании в сортировке все времена должны отсортироваться по неубыванию. Ниже вы можете увидеть код используемой сортировки:
//
//my_time a[n];
//
////заполнение массива
//for (int i = 0; i < n; ++i) {
//    for (int j = i; j < n; ++j) {
//        if (a[j] < a[i]) {
//            swap(a[i], a[j]);
//        }
//    }
//}
//
//Техничная часть
//Вам необходимо реализовать структуру my_time, у которой есть поля day, hour, minute, second. Еще должен быть оператор <, использование которого в вышенаписанной сортировке отсортирует массив времен по неубыванию.
//
//Примечание
//Вам не нужно ничего делать, чтобы функция swap работала, она будет работать сама по себе без вашего вмешательства.
//
//Sample Input:
//8
//1 3 24 21
//-1 18 35 58
//-2 22 3 17
//0 0 24 43
//0 14 38 46
//1 0 46 57
//1 0 1 53
//1 0 3 34
//
//Sample Output:
//-2 22 3 17
//-1 18 35 58
//0 0 24 43
//0 14 38 46
//1 0 1 53
//1 0 3 34
//1 0 46 57
//1 3 24 21

struct my_time
{
    int day, hour, minute, second;
};

bool operator<(const my_time &a, const my_time &b)
{
    if ((a.day * 86400
         + a.hour * 3600
         + a.minute * 60
         + a.second) < (b.day * 86400
                        + b.hour * 3600
                        + b.minute * 60
                        + b.second))
        return 1;
    else
        return 0;
}