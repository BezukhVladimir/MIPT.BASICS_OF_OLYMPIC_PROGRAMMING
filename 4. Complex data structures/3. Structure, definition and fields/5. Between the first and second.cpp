//Между первой и второй...
//В этой задаче нам снова понадобятся списки из предыдущей задачи, однако в этот раз мы их немного усложнили. Как вы можете видеть, в списках теперь два поля - привычный нам указатель на следующий элемент и целое число val. В нем мы храним значение очередной ячейки списка.
//
//Мы составили для вас два списка, значения в которых отсортированы по неубыванию. Вам необходимо составить третий список, который будет содержать в себе те же самые значения, и при этом так же будет отсортирован по неубыванию.
//
//Техничная часть
//Вам необходимо реализовать функцию merge, которая на вход принимает два указателя на node - начало соответствующих списков. Функция должна вернуть указатель на начало объединенного списка. Гарантируется, что данные вам списки не зациклены, а также что в последних ячейках списков указатели на следующий элемент нулевые. Ваш список должен содержать в себе все те же значения, что и данные два, и идти они должны по неубыванию. Пожалуйста, не надо зацикливать итоговый список. Кстати, вы можете делать с данными списками что угодно, мы не будем проверять, что вы их не меняли.
//
//Sample Input:
//4
//1 7 8 9
//6
//1 2 3 3 9 10
//
//Sample Output:
//1 1 2 3 3 7 8 9 9 10

struct node {
    node *next;
    int val;
};

node* merge(node *a, node *b)
{
    if (a == 0)
        return b;

    if (b == 0)
        return a;

    if (a->val < b->val) {
        a->next = merge(a->next, b);
        return a;
    } else {
        b->next = merge(a, b->next);
        return b;
    }
}